# You Betta Werk! ðŸ’…

`werk` is a simplistic and opinionated command runner, similar to `just`, and
also a simplistic build system, similar to `make`.

> [!CAUTION]
> Werk is in an early alpha stage. Use at your own risk. It may eat
> your files, so run `git commit` before trying it out.

# Why?

GNU make is extremely useful, but very hard to use correctly, especially if you
have modern expectations of your build system, and you just want a convenient
way to execute build scripts, create asset packs, or run housekeeping tasks in
your project.

`just` is also extremely useful, and easy to use, but cannot build files. It can
only run commands, delegating to `make`, `cargo`, or other build systems to
actually produce output. Furthermore, it can be difficult to write
cross-platform `Justfile`s, usually relying on a platform-specific shell
availability.

# Features

- **Cross-platform:** Windows is a first-class citizen - no dependency on a
  POSIX-compliant shell (or any shell). Werk files work on all platforms out of
  the box.
- **Declarative:** Werk files are simple TOML documents, and human-friendly.
  They are designed to be written by hand.
- **Commands:** Real support for executing project scrips, similar to `just`
  recipes or `.PHONY` Make targets. A command recipe will be run at most once
  per `werk` invocation.
- **Build recipes:** Files can be built from Make-like patterns, and rebuilt
  according to modification time.
- **Advanced outdatedness:** `werk` does more than just compare file
  modification timestamps. Metadata is cached between runs to support additional
  sources of "outdatedness".
- **Autoclean:** Werk is aware of which files it has generated, and can
  automatically clean them up from the output directory.
- **Globbing:** Filesystem glob patterns work out of the box, and can be used
  reliably in dependencies. `werk` caches a hash of the glob result between
  builds, so file deletion is detected as a change. Globbing is based on the
  `globset` crate, which comes from `ripgrep`.
- **Separate output directory:** All files produces by `werk` are put in a
  separate output directory, which is always what you want. This is cumbersome
  with Make.
- **Paths can contain spaces:** Make simply cannot deal.
- **Depfile support:** Depfile output from C-like compilers such as `clang`,
  `gcc`, `cl`, `glslc`, etc. are specially supported in build recipes. When a
  recipe contains a `depfile` dependency, it is automatically built and included
  when evaluating the dependencies of that recipe.
- **.gitignore support:** The `ignore` crate is used to hide files from `werk`.
- **Dry-run:** Pass `--dry-run` to diagnose the build process without generating
  any output.
- Of course, build recipes and commands run in parallel when possible.

# Limitations

- **Cross-platform:** Paths and commands must work across all platforms.
- **Declarative:** Very advanced build logic can be difficult to express. If the
  limited expression support in `werk` is insufficient (and can't be easily
  supported in the model), consider using a more advanced solution like GNU
  make, CMake, ninja-build, scons, cargo-script, etc.
- **Separate output directory:** It is not possible to put output files next to
  input files, and files in the output directory are assumed to be generated by
  `werk`.
- **Multiple recipes matching the same pattern:** As opposed to Make, build
  recipes are not disambiguated by their inputs. This means that for example it
  is not possible to have two recipes that match `%.o`, where one takes `%.c` as
  input and the other takes `%.cpp` as input.
  - *Workaround 1:* Define separate recipes `%.c.o` and `%.cpp.o` to build the two
    kinds of source files with different output file extensions.
  - *Workaround 2:* Use capture patterns, so the build recipe pattern is
    `%.(c|cpp)`, and use expressions and local build recipe variables to
    generate the correct compiler arguments based on the captured pattern `{0}`,
    which will evaluate to either "c" or "cpp".
- **Multiple outputs from a single recipe:** This is not supported. The typical
  example is a code generator that outputs both a header file and a source file,
  like `bison`. *Note: This may be supported in the future.*
  - *Workaround:* Define a command recipe that produces the files in the
    workspace directory, and set the command as a dependency of another source
    file. Take care that the code generator only sets the modification time of
    its outputs when they actually changed.
- **Detailed parallelism control:**  `werk` currently does not support marking
  specific recipes as "non-parallel". The only way to control parallelism is by
  supplying the `--jobs` command line parameter, which controls the number of
  worker threads.

## Non-goals

- `werk` will probably never be fastest.
    1. User friendliness is always higher priority.
    2. Reporting "no changes" quickly is specifically not a goal. Use Ninja if
    this is important to you. Typically, `werk` is invoked when the user has
    actually made changes.
    3. That said, `werk` does try to be reasonably fast, and is implemented in
    Rust using best practices.
- `werk` will probably never support all use cases.
    1. It is designed to support the use cases that are important to me, the
       author.
    2. The needs of build systems are vast and varied. Use the one that fits
       your purposes, or file a feature request if you believe that `werk` would
       be greater if it could reasonably support it.
- `werk` will never be a scripting language. It is strictly declarative with
  minimal support for logic and expressions, but doesn't have (and won't have)
  loop constructs.

# Example

In a project's `werk.toml`:

```toml
[config]
# Put build artifacts in `<ROOT>/target` (this is the default). Maybe you want
# a different output directory per build profile/arch/platform?
out-dir = "target"

[global]
# Global variables can be overridden on the command line, by passing
# `-Dcompletion-message=...`.
completion-message = "Build complete!"

# Find path to the `clang` executable from the PATH environment variable.
cc.which = "clang"
# Use clang for linking as well.
ld = "{cc}"

# Command to build the example binary.
[command.build]
build = ["example{EXE_SUFFIX}"]
post-message = "{completion-message}"

# Recipe to create an object file from a C source file.
[build.'%.o']
in = "{%}.c"
command = "{cc} -c -o <out> <in>"

# Recipe to create the final executable.
[build.'example{EXE_SUFFIX}']
in = ["example.o", "main.o"]
command = "{ld} -o <out> <in*>
```

Example output:

```
# Run the build command:

$ werk build
[OK] /example.o
[OK] /main.o
[OK] /example.exe
[OK] build: Build complete!

# Build files explicitly. Note: This is an abstract path (see below)
# example.o will be placed at target/example.o.

$ werk example.o
[OK] /example.o
```

## `werk.toml` Reference

```toml
# Configuration of werk itself, corresponding to command-line arguments
# to the `werk` command.
[config]

# Optional: Set "target" as the output directory.
# Default is "target".
out-dir = "target"

# Optional: When `werk` is invoked with no arguments, run this recipe.
# The default is to list the available recipes.
default = "build"


# Global variables available to all recipes.
# These can all be overridden from the command-line.
[global]

# Custom variable
normal-string = "just a value"

# Which expression: Set `{cc}` to the filesystem path to `clang`
cc.which = "clang"

# Glob expression
input-files.glob = "**/*.c"



# Define a command, invokable from the command-line as `werk command-name`.
[command.command-name]

# Optional: Build these files before executing the command.
build = ["file1.o", "file2.o"]

# Set a recipe-local variable, evaluated in order, before commands.
vars.foo = "..."

# Optional: String or list of strings containing shell commands to execute.
command = "echo Hello, World!"

# Optional: Print message in the output before building dependencies and executing commands.
pre-message = "Before command-name"

# Optional: Print message in the output after building dependencies and executing commands.
post-message = "After command-name"

# Optional: Disabling capturing stdout of the command, forwarding it to the terminal.
capture = false



# Define a build recipe. See pattern syntax below.
[build.'pattern']

# Optional: Input file(s) expression.
in = "..."

# Optional: Path to a `.d` depfile generated by a compiler.
depfile = "..."

# Set a recipe-local variable, evaluated in order, before commands.
vars.foo = "..."

# Required: Command or list of commands to execute to build the output.
command = "..."

# Optional: Print message in the output *after* building dependencies,
# but before executing commands.
pre-message = "Before {out}"

# Optional: Print message in the output after executing commands.
post-message = "After {out}"
```

# Outdatedness

`werk` tracks the outdatedness of all files generated by recipes.

Outdatedness is tracked *per-variable*, so if a recipe uses a variable that is
derived from one of the following, the recipe will be rebuilt if the variable is
outdated.

- **Modification time of input files:** Like Make.

- **Results of glob patterns**. If the list of files produced by a glob pattern
  changes between runs, any recipes and variables using the list are considered
  outdated.

- **Used environment variables:** If an environment variable changes between
  runs, any recipes and variables using the value are considered outdated.
  Values from environment variables are cached by their hash, to avoid storing
  secrets between runs.

- **Results of `which` expressions:** If the `PATH` environment variable changes
  between runs in such a way that the executable path is different, or if the
  modification time of the resolved executable changes, any recipes and
  variables using the path are considered outdated. Note that command names that
  appear as part of the `command` body of recipes are implicitly be-whiched.

- **Modification time of `werk.toml`:** All build recipes are considered
  outdated if their output file exists, but is older than `werk.toml`.

Outdatedness is transitive. If a recipe depends on another recipe that is
outdated, that recipe is also considered outdated.

Note that command recipes are always "outdated" (corresponding to `.PHONY`
targets in Make), so if a build recipe depends on a command recipe, it will
always be rebuilt on every run.

If a build recipe has no input files, any variables used in the recipe will
still contribute to its outdatedness. If its output file does not exist, it will
always be considered outdated.

Metadata tracking outdatedness is persisted between runs, and is stored in
`<out-dir>/.werk-cache`.

# String interpolation syntax

String interpolation is loosely based on Rust's format strings, using `{var}`,
or `{var:...}` when any additional operations need to be applied while
formatting the interpolated string. Additionally, the `<var>` syntax can be used
in commands to interpolate a native OS filesystem path (see below).

When the interpolated variable is a an array (say, a list of files), the syntax
`{var*}` can be used to expand the list separated by a space (useful when
passing a list of files to a command), or the syntax `{var[N]}` can be used to
interpolate the Nth element in the array.

## Formatting options

- `{...:.ext1=.ext2}`: Replace the file extension `.ext1` with `.ext2`. The
  leading period in the extension is mandatory. If the input is a list, the
  operation is applied recursively to all elements. If the input is not a path,
  or the path does not have the `.ext1` extension, the operation does nothing.
- `{...:dedup}`: Remove duplicate entries of a list, preserving the order of the
  input. Does nothing if the input is not a list.
- `{...:dir}`: The directory part of a path (without the trailing slash).
- `{...:filename}`: The file-within-directory part of a path (without a leading
  slash).
- `{...:lowercase}`: Convert the input to Unicode lowercase.
- `{...:uppercase}`: Convert the input to Unicode uppercase.

## Automatic variables

Special variables correspond loosely to the naming of special variables in Make,
as a mnemonic (though note: the syntax is different; there is no `$`,
interpolation is always inside `{...}` or `<...>`).

All of these may also be used with formatting options.

- `{in}`, `<in>`, `{^}`, or `<^>`: The abstract or filesystem path(s) of the
  first input file of a build recipe ("prerequisite").
- `{in*}`, `<in*>`: The abstract or filesystem paths of all prerequisites. This
  list is deduplicated; each path will only appear once. Note that this may be a
  list when the recipe has multiple inputs. Equivalent to `{+:dedup}`
- `{out}`, `<out>`, `{@}`, or `<@>`: The abstract or concrete path to the output
  file(s) of a build recipe.
- `{?}` or `<?>`: The abstract or filesystem path(s) of all the prerequisites
  that are newer than the target of a build recipe.
- `{%}`: The matched stem of the pattern. For example, when `src/test.c` has
  been matched against the pattern `%.c`, this is `src/test`. Only valid in
  build recipes. *Note: This mnemonic differs from `$%` in Make, which is only
  useful in archive operations.*
- `{+}` or `<+>`: Same as `in`, except that duplicate entries are preserved in
  the order they were declared. This is primarily useful for use in linking
  commands where it is meaningful to repeat library file names in a particular
  order.
- `{@D}`: The directory part of the file name of the target. Same as
  `{out:dir}`.
- `{@F}`: The file-within-directory part of the file name of the target. Same as
  `{out:filename}`.

## Built-in constants

By convention, built-in constants are UPPER_SNAKE_CASE.

- `{ROOT}` or `<ROOT>`: The abstract or filesystem path to the project root. The
  abstract root path is always `/`. The filesystem path is always the directory
  containing `werk.toml`.
- `{EXE_SUFFIX}`: On Windows, this is `.exe`. On other systems, this is the
  empty string.
- `{OS}`: The host operating system.
  - `windows`
  - `linux`
  - `macos`
  - `freebsd`
  - `dragonfly`
  - `openbsd`
  - `netbsd`
- `{OS_FAMILY}`: The host operating system family.
  - `windows` on Windows.
  - `unix` on Linux, macOS, and the BSDs.
- `{ARCH}`: The host architecture.
  - `x86_64`
  - `aarch64`
- `{ARCH_FAMILY}`:
  - `x86`
  - `arm`
- `{EMPTY}`: The empty string. This exists because TOML does not support empty
  strings in some contexts, like keys in tables.

## Pattern matching

Patterns occur in a couple of contexts: build recipes and `match` expressions
(see below). Patterns are strings with some additional magic tokens.

- `%` matches any sequence of characters (including the empty string), and may
  occur at most once in a pattern. The matched sequence becomes the "pattern
  stem".
- `(a|b|c)` is a capture group, matching either `a`, `b`, or `c` exactly.
  Patterns can contain any number of capture groups.

Example, given the pattern `%.(c|cpp)`:

- The string `"foo.c"` will match. The stem is `foo`, and capture group 0 is `c`.
- The string `"foo/bar/baz.cpp"` will match. The stem is `foo/bar/baz`, and
  capture group 0 is `cpp`.
- The string `"foo.h"` will not match, because none of the variants in the
  capture group apply.
- The string `"abc"` will not match, because the period is missing.

When a pattern-match is "in scope" (i.e. within a build recipe, or while
evaluating a `match` statement), the stem and capture groups are available for
string interpolation through the special syntax `{%}` (note: braces required)
and `{0}` (the index of the capture group).

> **Note:** TOML does not support empty strings as keys in key-value pairs, and
> both build recipes and match expressions are expressed as key-value pairs in
> TOML tables. The special constant `"{EMPTY}"` can be used to produce an empty
> string, without it looking like an empty string to TOML.

When multiple patterns match in the same context (say, more than one build
recipe pattern matches the output file name, or a match expression has more than
one arm), the "most specific" match is chosen:

- A pattern without a `%` stem is "more specific" than a pattern that has a
  stem.
- A pattern that matches the input with a shorter stem is "more specific" than
  a pattern that matches a longer stem.
- Capture groups do not affect the "specificity" of a pattern.

Given the patterns `%.c`, `%/a.c`, `foo/%/a.c`, `foo/bar/a.c`, this is how
matches will be chosen based on various inputs:

- `"bar/b.c"`: The pattern `%.c` will be chosen, because it does not match the
  other patterns. The stem is `"bar/b"`.
- `"foo/a.c"`: The pattern `%/a.c` will be chosen, because it produces the
  shortest stem `"a"`. The stem is `foo`.
- `"foo/foo/a.c"`: The pattern `foo/%/a.c` will be chosen over `%.c` and
  `%/a.c`, because it produces a shorter stem. The stem is `foo`.
- `"foo/bar/a.c"`: The pattern `foo/bar/a.c` will be chosen over `foo/%/a.c`,
  because the pattern is literal exact match without a stem.

**Conflicts:** It's possible to construct patterns that are different, but match
the same input with the same "specificity". For example, both patterns
`foo/%/a.c` and `%/foo/a.c` match the input `"foo/foo/a.c"` equally. When such a
situation occurs, that's a hard error.

### Example build recipe

```toml
# Build a GLSL shader using stem and a capture group
[build.'%.(frag|vert|comp)']
in = "{%}.{0}"
command = "glslc -o <out> <in>"
```

# Expressions

When setting the value of a variable, either in the `[global]` section or
locally in a recipe, and string interpolation is not sufficient, there is limited
support for evaluating expressions.

In TOML, expressions are tables with special keys:

- `{ env = "MY_ENV" }`: Read the environment variable `MY_ENV`.
- `{ shell = "command" }`: Run `command` and set the variable to its stdout
  output. Implicitly sets `NO_COLOR` and trims whitespace from the output.
- `{ which = "command" }`: Query the `PATH` environment variable to find the
  filesystem path to `command`. Evaluation fails early if the command is not
  found. Note that this is different from `{ shell = "which command" }` because
  the `which` expression works on all platforms, and the `which` command line
  utility does not exist out of the box on Windows. This expression tracks
  outdatedness between runs.
- `{ glob = "**/*.c" }`: Glob the workspace for files matching the glob pattern.
  This expression tracks outdatedness between runs, so recipes deriving their
  input from the glob pattern will be outdated when files are added/removed.
  *Note: The output directory is not included!*
- `{ from = "variable", ... }`: Given an input variable identifier, chain it
  through one or more "chaining expressions" to produce an output value (see
  below). Note that `variable` must be an identifier that is available either in
  the global scope or locally in the current recipe.
- `{ from = { ... } }`: Given an input expression, chain it through one or more
  "chaining expressions" (see below).
- `{ error = "message" }`: Produce an error and abort the current recipe (or the
  whole program, if in the global scope). This is useful to detect invalid
  configuration values passed on the command-line.

## Chaining expressions

These are special keys added inside other expressions, modifying the result of
that expression in some way, or introducing a side-effect. In string expressions
of chaining expressions, the original value is available as the "implicit value"
`{}`.

If multiple chaining expressions exist as part of the same expression, they are
evaluated in order as they appear, though note that only one of each type can
appear in a single expression (due to TOML limitations - expressions are TOML
tables, and keys in TOML tables must be unique).

- `{ ..., then = "format" }`: Pipe the result through a string expression format
  operation. The formatting operation is applied recursively if the input is a
  list.
- `{ ..., match = { 'foo' = "...", 'bar' = "..." } }`: Match patterns. See
  below.
- `{ ..., warning = "message" }`: Emit a warning and pass the value unaltered.
- `{ ..., info = "message" }`: Emit an informational message and pass the value
  unaltered.
- `{ ..., help = "message" }`: When the expression fails for whatever reason,
  print the help message to the user. For example, this might be used together
  with `which` to guide the user to install a command-line utility.
- `{ ..., patsubst = { pattern = "pattern", replacement = "replacement" } }`: If
  the value matches the pattern, replace it with `replacement`. Pattern captures
  are available inside the replacement.

Example replacing the extension of a glob pattern and adding a prefix:

```toml
[global]
object-files = { glob = "**/*.c", then = "prefix/{:.c=.o}" }
```

More complicated expressions are best represented as block tables:

### `match` expression

`match` matches the input expression against a list of patterns (using recipe
pattern syntax and logic), and passes the input through unaltered when none of
the patterns match the input. When the input is a list, the match expression is
applied recursively. The catch-all pattern '%' can be used as a fallback, which
may then generate an error.

```toml
[global]
# Can be overridden on the command-line by passing `-Dbuild-type=release`.
build-type = "debug"

[global.cflags]
from = "build-type"
match.'debug' = "-g -O0"
match.'release' = "-O3"
match.'%' = { error = "unrecognized build configuration: {%}" }
else = ""
```

> [!TIP]
> The expressions that make up a recipe are evaluated in full before any
> commands are executed for that recipe. This means that a recipe doesn't fail
> halfway when its expressions fail to evaluate, but it also means that
> informational expressions (`info` and `warn`) will not be interleaved with
> running commands, even if they are present within the `command` body of a
> recipe.

# Design rationales

## Advanced Outdatedness

Let's be realistic: File modification time just doesn't cut it in many cases.
Relying on that alone is especially problematic in glob patterns, which would
have been so convenient to have available in Make and similar systems, but is
very hard to achieve reliably.

Fundamentally, the design decision is to introduce a `.werk-cache` metadata file
that tracks information between runs. This has the added benefit that we can
also track other sources of outdatedness, like environment variables (especially
`PATH`), which means that `werk` can track when a compiler is changed or
updated.

## Abstract filesystem paths

Filesystem interaction is very platform-specific. For example, different
operating systems use different path separators (`/` versus `\`), and some
filenames are reserved on Windows.

`werk` uses an abstract representation of filesystem paths that always uses a
forward slash as the separator, and it is always relative to the project root
(the same directory as `werk.toml`). Abstract paths are *always* valid UTF-8,
and may only contain characters and file names that are valid on all supported
platforms.

For example, `werk` detects if you are trying to use or create a file named
`con`, which is a reserved name on Windows, or if you attempt to use a backslash
`\` in a path, which would be interpreted differently on different platforms.

Abstract paths in `werk` refer to the "logical" workspace of the project, and
cannot represent a file outside of that workspace. Using a single path
representation across all platforms vastly simplifies the task of writing
pattern matching recipes that work across all platforms.

When interpolating paths in a string expression, they can be interpolated either
as `{path}` or `<path>`. The former interpolates the literal abstract path,
while the former resolves the abstract path as a native OS path, which is either
in the workspace-directory if it exists, or in the target/output directory if it
can be built by a recipe.

## No shell

Commands are executed directly. The `werk` executable parses shell-like commands
and executes them without going through an external process like `sh`. The
`which` crate is used to determine the actual path to an executable.

The reason behind this choice is that shells parse command line arguments
differently on different platforms. For example, UNIX shells perform glob
expansion before executing the process, while Windows shells do not, and just
pass the glob pattern verbatim to the process. This makes it difficult to ensure
that the same command works the same on different platforms.

Building commands from a string is sensitive to whitespace and quoting: When
interpolating a path using `<...>` and outside explicit quotes, the argument is
passed to the command as one whole argument (including spaces). Inside explicit
quotes, such as `"<a> <b>"`, both paths are passed as a single argument,
including the whitespace.

The drawback is that some common shell operations don't work out of the box,
namely piping the output of a command to a file or another process.

Command-line executables spawned by `werk` always run with the project root as
the working directory.

## TOML

Using TOML means that `werk.toml` can be easily parsed or generated by other tools.

However, some things cannot be hardcoded, so `werk` includes a limited support
for expressions, which generally take the form of inline tables in TOML.

Example:

```toml
[global]
normal-string-variable = "hello"
# Glob expression using implicit table notation in TOML.
input-files.glob = "**/*.c"
# which expression using explicit inline table notation in TOML.
cc = { which = "clang" }
```

## Roadmap

- [ ] Specialized alternative to TOML, with less verbose expressions? This is
  complicated because we would also want an LSP implementation for IDE support.
- [ ] IDE integration to run individual tasks.
- [ ] WASM host support for the runner.
