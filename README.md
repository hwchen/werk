# You Betta Werk! ðŸ’…

`werk` is a simplistic and opinionated command runner, similar to `just`, and
also a simplistic build system, similar to `make`.

## Why?

GNU make is extremely useful, but very hard to use correctly, especially if you
have modern expectations of your build system, and you just want a convenient
way to execute build scripts, create asset packs, or run housekeeping tasks in
your project.

`just` is also extremely useful, and easy to use, but cannot build files. It can
only run commands, delegating to `make`, `cargo`, or other build systems to
actually produce output. Furthermore, it can be difficult to write
cross-platform `Justfile`s, usually relying on a platform-specific shell
availability.

## Features

- **Cross-platform:** Windows is a first-class citizen - no dependency on a
  POSIX-compliant shell (or any shell). Werk files work on all platforms out of
  the box.
- **Declarative:** Werk files are simple TOML documents, and human-friendly.
  They are designed to be written by hand.
- **Commands:** Real support for executing project scrips, similar to `just`
  recipes or `.PHONY` Make targets. A command recipe will be run at most once
  per `werk` invocation.
- **Build recipes:** Files can be built from Make-like patterns, and rebuilt
  according to modification time.
- **Autoclean:** Werk is aware of which files it has generated, and can
  automatically clean them up from the output directory.
- **Globbing:** Filesystem glob patterns work out of the box, and can be used
  reliably in dependencies. `werk` caches a hash of the glob result between
  builds, so file deletion is detected as a change. Globbing is based on the
  `globset` crate, which comes from `ripgrep`.
- **Separate output directory:** All files produces by `werk` are put in a
  separate output directory, which is always what you want. This is cumbersome
  with Make.
- **Paths can contain spaces:** Make simply cannot deal.
- **Depfile support:** Depfile output from C-like compilers such as `clang`,
  `gcc`, `cl`, `glslc`, etc. are specially supported in build recipes. When a
  recipe contains a `depfile` dependency, it is automatically built and included
  when evaluating the dependencies of that recipe.
- **.gitignore support:** The `ignore` crate is used to hide files from `werk`.
- Of course, build recipes and commands run in parallel when possible.

## Limitations

- **Cross-platform:** Paths and commands must work across all platforms.
- **Declarative:** Very advanced build logic can be difficult to express. If the
  limited expression support in `werk` is insufficient (and can't be easily
  supported in the model), consider using a more advanced solution like GNU
  make, CMake, ninja-build, scons, cargo-script, etc.
- **Separate output directory:** It is not possible to put output files next to
  input files, and files in the output directory are assumed to be generated by
  `werk`.
- **Multiple recipes matching the same pattern:** As opposed to Make, build
  recipes are not disambiguated by their inputs. This means that for example it
  is not possible to have two recipes that match `%.o`, where one takes `%.c` as
  input and the other takes `%.cpp` as input.
  - *Workaround 1:* Define separate recipes `%.c.o` and `%.cpp.o` to build the two
    kinds of source files with different output file extensions.
  - *Workaround 2:* Use capture patterns, so the build recipe pattern is
    `%.(c|cpp)`, and use expressions and local build recipe variables to
    generate the correct compiler arguments based on the captured pattern `{0}`,
    which will evaluate to either "c" or "cpp".
- **Multiple outputs from a single recipe:** This is not supported. The typical
  example is a code generator that outputs both a header file and a source file,
  like `bison`. *Note: This may be supported in the future.*
  - *Workaround:* Define a command recipe that produces the files in the
    workspace directory, and set the command as a dependency of another source
    file. Take care that the code generator only sets the modification time of
    its outputs when they actually changed.
- **Detailed parallelism control:**  `werk` currently does not support marking
  specific recipes as "non-parallel". The only way to control parallelism is by
  supplying the `--jobs` command line parameter, which controls the number of
  worker threads.

## Non-goals

- `werk` will probably never be fastest.
    1. User friendliness is always higher priority.
    2. Reporting "no changes" quickly is specifically not a goal. Use Ninja if
    this is important to you. Typically, `werk` is invoked when the user has
    actually made changes.
    3. That said, `werk` does try to be reasonably fast, and is implemented in
    Rust using best practices.
- `werk` will probably never support all use cases.
    1. It is designed to support the use cases that are important to me, the
       author.
    2. The needs of build systems are vast and varied. Use the one that fits
       your purposes, or file a feature request if you believe that `werk` would
       be greater if it could reasonably support it.
- `werk` will never be a scripting language. It is strictly declarative with
  minimal support for logic and expressions.

## Example

In a project's `werk.toml`:

```toml
[global]
# Put build artifacts in `<ROOT>/target` (this is the default). Maybe you want
# a different output directory per build profile/arch/platform?
out-dir = "target"

# Find path to the `clang` executable from the PATH environment variable.
cc.which = "clang"
# Use clang for linking as well.
ld = "{cc}"

# Command to build the example binary.
[command.build]
build = ["example{EXE_SUFFIX}"]
post-message = "Build complete!"

# Recipe to create an object file from a C source file.
[build.'%.o']
in = "{%}.c"
command = "{cc} -c -o <out> <in>"

# Recipe to create the final executable.
[build.'example{EXE_SUFFIX}']
in = ["example.o", "main.o"]
command = "{ld} -o <out> <in*>
```

How to use:

```
# Run the build command:

$ werk build
[OK] /example.o
[OK] /main.o
[OK] /example.exe
[OK] build: Build complete!

# Build files explicitly. Note: This is an abstract path (see below)
# example.o will be placed at target/example.o.

$ werk example.o
[OK] /example.o
```

## `werk.toml` Reference

```toml
# Global variables available to all recipes, including build patterns.
# These can all be overridden from the command-line.
[global]

# Optional: Set "target" as the output directory.
# Default is "target".
out-dir = "target"

# Optional: Set the number of parallel jobs.
# Default is the number of CPU cores.
jobs = 8

# Optional: When `werk` is invoked with no arguments, run this recipe.
# The default is to list the available recipes.
default = "build"

# Custom variable
normal-string = "just a value"

# Which expression: Set `{cc}` to the filesystem path to `clang`
cc.which = "clang"

# Glob expression
input-files.glob = "**/*.c"



# Define a command, invokable from the command-line as `werk command-name`.
[command.command-name]

# Optional: Build these files before executing the command.
build = ["file1.o", "file2.o"]

# Optional: String or list of strings containing shell commands to execute.
command = "echo Hello, World!"

# Set a recipe-local variable, evaluated in order, before commands. Supports expressions.
vars.foo = "..."

# Optional: Print message in the output before building dependencies and executing commands.
pre-message = "Before command-name"

# Optional: Print message in the output after building dependencies and executing commands.
post-message = "After command-name"



# Define a build recipe. See pattern syntax below.
[build.'pattern']

# Optional: Input file(s) expression.
in = "..."

# Optional: Path to a `.d` depfile generated by a compiler.
depfile = "..."

# Required: Command to execute to build the output.
command = "..."

# Set a recipe-local variable, evaluated in order, before commands. Supports expressions.
vars.foo = "..."

# Optional: Print message in the output *after* building dependencies but before executing commands.
pre-message = "Before build"

# Optional: Print message in the output after executing commands.
post-message = "After build"
```

## String interpolation syntax

String interpolation is loosely based on Rust's format strings, using `{var}`,
or `{var:...}` when any additional operations need to be applied while
formatting the interpolated string. Additionally, the `<var>` syntax can be used
in commands to interpolate a native OS filesystem path (see below).

When the interpolated variable is a an array (say, a list of files), the syntax
`{var*}` can be used to expand the list separated by a space (useful when
passing a list of files to a command), or the syntax `{var[N]}` can be used to
interpolate the Nth element in the array.

### Formatting options

- `{...:.ext1=.ext2}`: Replace the file extension `.ext1` with `.ext2`. The
  leading period in the extension is mandatory. If the input is a list, the
  operation is applied recursively to all elements. If the input is not a path,
  or the path does not have the `.ext1` extension, the operation does nothing.
- `{...:dedup}`: Remove duplicate entries of a list, preserving the order of the
  input. Does nothing if the input is not a list.
- `{...:dir}`: The directory part of a path (without the trailing slash).
- `{...:filename}`: The file-within-directory part of a path (without a leading
  slash).
- `{...:lowercase}`: Convert the input to Unicode lowercase.
- `{...:uppercase}`: Convert the input to Unicode uppercase.

### Automatic variables

Special variables correspond loosely to the naming of special variables in Make,
as a mnemonic (though note: the syntax is different; there is no `$`,
interpolation is always inside `{...}` or `<...>`).

All of these may also be used with formatting options.

- `{in}`, `<in>`, `{^}`, or `<^>`: The abstract or filesystem path(s) of the
  input file(s) of a build recipe ("prerequisite"). This list is deduplicated;
  each path will only appear once. Note that this may be a list when the recipe
  has multiple inputs. Equivalent to `{+:dedup}`.
- `{out}`, `<out>`, `{@}`, or `<@>`: The abstract or concrete path to the output
  file(s) of a build recipe.
- `{?}` or `<?>`: The abstract or filesystem path(s) of all the prerequisites
  that are newer than the target of a build recipe.
- `{%}`: The matched stem of the pattern. For example, when `src/test.c` has
  been matched against the pattern `%.c`, this is `src/test`. Only valid in
  build recipes. *Note: This mnemonic differs from `$%` in Make, which is only
  useful in archive operations.* 
- `{+}` or `<+>`: Same as `in`, except that duplicate entries are preserved in
  the order they were declared. This is primarily useful for use in linking
  commands where it is meaningful to repeat library file names in a particular
  order.
- `{@D}`: The directory part of the file name of the target. Same as
  `{out:dir}`.
- `{@F}`: The file-within-directory part of the file name of the target. Same as
  `{out:filename}`.

### Built-in constants

By convention, built-in constants are UPPER_SNAKE_CASE.

- `{ROOT}` or `<ROOT>`: The abstract or filesystem path to the project root. The
  abstract root path is always `/`. The filesystem path is always the directory
  containing `werk.toml`.
- `{EXE_SUFFIX}`: On Windows, this is `.exe`. On other systems, this is the
  empty string.
- `{OS}`:
    - `windows` on Windows.
    - `linux` on Linux.
    - `macos` on macOS.
- `{OS_KIND}`:
    - `windows` on Windows.
    - `unix` on Linux and macOS.

## Build Recipe Pattern Syntax

Build recipes are identified by a pattern that describes the file name of the
output that they generate. Patterns can contain interpolated string values,
which are evaluated in the "global" scope. For example, a build recipe pattern
producing an executable file may wish to use the `{EXE_SUFFIX}` global constant.

Patterns may have a single "stem" placeholder `%`, which matches any substring.
The value of the stem is available inside the build recipe as `{%}`.

Patterns are string expressions, except they have the following additional
limitations: Patterns must always evaluate to a valid abstract file path, and
the literal characters `%`, `(`, and `)` must be escaped.

### Capture Groups

Build recipe patterns support a limited form of capture groups, which have the
syntax `(a|b|c)`. Build patterns can contain any number of capture groups, and
their value can be accessed inside the build recipe by their index `{0}`, `{1}`,
etc.

Example:

```toml
# Recipe to compile a GLSL shader (vertex, fragment, or compute).
[build.'%.(frag|vert|comp).spv']
in = "{%}.{0}"
command = "glslc -o <out> <in>"
```

## Expressions

When setting the value of a variable, either in the `[global]` section or
locally in a recipe, and string interpolation is not sufficient, there is limited
support for evaluating expressions.

In TOML, expressions are tables with special keys:

- `{ env = "MY_ENV" }`: Read the environment variable `MY_ENV`.
- `{ shell = "command" }`: Run `command` and set the variable to its stdout
  output. Implicitly sets `NO_COLOR` and trims whitespace from the output.
- `{ which = "command" }`: Query the `PATH` environment variable to find the
  filesystem path to `command`. Evaluation fails early if the command is not
  found. Note that this is different from `{ shell = "which command" }` because
  the `which` expression works on all platforms, and the `which` command line
  utility does not exist out of the box on Windows.
- `{ glob = "**/*.c" }`: Glob the workspace for files matching the glob pattern.
  This also implicitly creates a cache entry for the glob pattern, so recipes
  deriving their input from the glob pattern will be outdated when files are
  added/removed. *Note: The output directory is not included!*
- `{ with: "input", then: expr }`: Given an input variable, chain it through
  `expr` to produce an output value.

### Chaining expressions

Expression tables can have the optional key `then`, which pipes the expression
result to a new expression, where the output of the previous expression is an
implicit interpolation variable.

Example, replacing the extension of a glob pattern and adding a prefix:

```toml
[global]
object-files = { glob = "**/*.c", then = "prefix/{:.c=.o}" }
```

More complicated expressions are best represented as block tables:

### `match` expression

```toml
[global]
build-type = "debug"

[global.cflags]
match = "{build-type}"
when.debug = "-g -O0"
when.release = "-O3"
else = ""
```

## Design rationales

### Abstract filesystem paths

Filesystem interaction is very platform-specific. For example, different
operating systems use different path separators (`/` versus `\`), and some
filenames are reserved on Windows.

`werk` uses an abstract representation of filesystem paths that always uses a
forward slash as the separator, and it is always relative to the project root
(the same directory as `werk.toml`). Abstract paths are *always* valid UTF-8,
and may only contain characters and file names that are valid on all supported
platforms.

For example, `werk` detects if you are trying to use or create a file named
`con`, which is a reserved name on Windows, or if you attempt to use a backslash
`\` in a path, which would be interpreted differently on different platforms.

Abstract paths in `werk` refer to the "logical" workspace of the project, and
cannot represent a file outside of that workspace. Using a single path
representation across all platforms vastly simplifies the task of writing
pattern matching recipes that work across all platforms.

When interpolating paths in a string expression, they can be interpolated either
as `{path}` or `<path>`. The former interpolates the literal abstract path,
while the former resolves the abstract path as a native OS path, which is either
in the workspace-directory if it exists, or in the target/output directory if it
can be built by a recipe.

### No shell

Commands are executed directly. The `werk` executable parses shell-like commands
and executes them without going through an external process like `sh`. The
`which` crate is used to determine the actual path to an executable.

The reason behind this choice is that shells parse command line arguments
differently on different platforms. For example, UNIX shells perform glob
expansion before executing the process, while Windows shells do not, and just
pass the glob pattern verbatim to the process. This makes it difficult to ensure
that the same command works the same on different platforms.

Building commands from a string is sensitive to whitespace and quoting: When
interpolating a path using `<...>` and outside explicit quotes, the argument is
passed to the command as one whole argument (including spaces). Inside explicit
quotes, such as `"<a> <b>"`, both paths are passed as a single argument,
including the whitespace.

The drawback is that some common shell operations don't work out of the box,
namely piping the output of a command to a file or another process.

Command-line executables spawned by `werk` always run with the project root as
the working directory.

### TOML

Using TOML means that `werk.toml` can be easily parsed or generated by other tools.

However, some things cannot be hardcoded, so `werk` includes a limited support
for expressions, which generally take the form of inline tables in TOML.

Example:

```toml
[global]
normal-string-variable = "hello"
# Glob expression using implicit table notation in TOML.
input-files.glob = "**/*.c"
# which expression using explicit inline table notation in TOML.
cc = { which = "clang" }
```

## Roadmap

- [ ] Specialized alternative to TOML, with less verbose expressions.